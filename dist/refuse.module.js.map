{"version":3,"file":"refuse.module.js","sources":["../node_modules/htm/src/build.mjs","../node_modules/htm/src/index.mjs","../src/utils/rfdc.js","../src/utils/isChildfulFiber.ts","../src/utils/isRefuseFiber.ts","../src/getEventListeners.js","../src/render.ts","../src/hooks.ts"],"sourcesContent":["import { MINI } from './constants.mjs';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst TAG_SET = 3;\nconst PROPS_ASSIGN = 4;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n// \ttreeify(\n//\t\tbuild`<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//\t\t[X, Y, Z]\n//\t)\n// returns:\n// \t{\n// \t\ttag: 'div',\n//\t\tprops: [ { href: [\"1\", X] }, Y ],\n// \t\tchildren: [ { tag: Z, props: [], children: [] } ]\n// \t}\nexport const treeify = (built, fields) => {\n\tconst _treeify = built => {\n\t\tlet tag = '';\n\t\tlet currentProps = null;\n\t\tconst props = [];\n\t\tconst children = [];\n\n\t\tfor (let i = 1; i < built.length; i++) {\n\t\t\tconst type = built[i++];\n\t\t\tconst value = built[i] ? fields[built[i++]-1] : built[++i];\n\n\t\t\tif (type === TAG_SET) {\n\t\t\t\ttag = value;\n\t\t\t}\n\t\t\telse if (type === PROPS_ASSIGN) {\n\t\t\t\tprops.push(value);\n\t\t\t\tcurrentProps = null;\n\t\t\t}\n\t\t\telse if (type === PROP_SET) {\n\t\t\t\tif (!currentProps) {\n\t\t\t\t\tcurrentProps = Object.create(null);\n\t\t\t\t\tprops.push(currentProps);\n\t\t\t\t}\n\t\t\t\tcurrentProps[built[++i]] = [value];\n\t\t\t}\n\t\t\telse if (type === PROP_APPEND) {\n\t\t\t\tcurrentProps[built[++i]].push(value);\n\t\t\t}\n\t\t\telse if (type === CHILD_RECURSE) {\n\t\t\t\tchildren.push(_treeify(value));\n\t\t\t}\n\t\t\telse if (type === CHILD_APPEND) {\n\t\t\t\tchildren.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn { tag, props, children };\n\t};\n\tconst { children } = _treeify(built);\n\treturn children.length > 1 ? children : children[0];\n};\n\nexport const evaluate = (h, built, fields, args) => {\n\tlet tmp;\n\n\t// `build()` used the first element of the operation list as\n\t// temporary workspace. Now that `build()` is done we can use\n\t// that space to track whether the current element is \"dynamic\"\n\t// (i.e. it or any of its descendants depend on dynamic values).\n\tbuilt[0] = 0;\n\n\tfor (let i = 1; i < built.length; i++) {\n\t\tconst type = built[i++];\n\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\n\n\t\tif (type === TAG_SET) {\n\t\t\targs[0] = value;\n\t\t}\n\t\telse if (type === PROPS_ASSIGN) {\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\n\t\t}\n\t\telse if (type === PROP_SET) {\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\n\t\t}\n\t\telse if (type === PROP_APPEND) {\n\t\t\targs[1][built[++i]] += (value + '');\n\t\t}\n\t\telse if (type) { // type === CHILD_RECURSE\n\t\t\t// Set the operation list (including the staticness bits) as\n\t\t\t// `this` for the `h` call.\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\n\t\t\targs.push(tmp);\n\n\t\t\tif (value[0]) {\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\n\t\t\t\tbuilt[0] |= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\n\t\t\t\t// Essentially the operation list gets optimized for potential future\n\t\t\t\t// re-evaluations.\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\n\t\t\t\tbuilt[i] = tmp;\n\t\t\t}\n\t\t}\n\t\telse { // type === CHILD_APPEND\n\t\t\targs.push(value);\n\t\t}\n\t}\n\n\treturn args;\n};\n\nexport const build = function(statics) {\n\tconst fields = arguments;\n\tconst h = this;\n\n\tlet mode = MODE_TEXT;\n\tlet buffer = '';\n\tlet quote = '';\n\tlet current = [0];\n\tlet char, propName;\n\n\tconst commit = field => {\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent.push(field ? fields[field] : buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[1] = field ? fields[field] : buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\n\t\t\t}\n\t\t\tmode = MODE_WHITESPACE;\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[2] = Object.assign(current[2] || {}, fields[field]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\n\t\t\tif (MINI) {\n\t\t\t\t(current[2] = current[2] || {})[buffer] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode >= MODE_PROP_SET) {\n\t\t\tif (MINI) {\n\t\t\t\tif (mode === MODE_PROP_SET) {\n\t\t\t\t\t(current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\telse if (field || buffer) {\n\t\t\t\t\tcurrent[2][propName] += field ? buffer + fields[field] : buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\tif (field) {\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuffer = '';\n\t};\n\n\tfor (let i=0; i<statics.length; i++) {\n\t\tif (i) {\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t\tcommit(i);\n\t\t}\n\n\t\tfor (let j=0; j<statics[i].length;j++) {\n\t\t\tchar = statics[i][j];\n\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tif (char === '<') {\n\t\t\t\t\t// commit buffer\n\t\t\t\t\tcommit();\n\t\t\t\t\tif (MINI) {\n\t\t\t\t\t\tcurrent = [current, '', null];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcurrent = [current];\n\t\t\t\t\t}\n\t\t\t\t\tmode = MODE_TAGNAME;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode === MODE_COMMENT) {\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\n\t\t\t\tif (buffer === '--' && char === '>') {\n\t\t\t\t\tmode = MODE_TEXT;\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = char + buffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (quote) {\n\t\t\t\tif (char === quote) {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (char === '\"' || char === \"'\") {\n\t\t\t\tquote = char;\n\t\t\t}\n\t\t\telse if (char === '>') {\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_TEXT;\n\t\t\t}\n\t\t\telse if (!mode) {\n\t\t\t\t// Ignore everything until the tag ends\n\t\t\t}\n\t\t\telse if (char === '=') {\n\t\t\t\tmode = MODE_PROP_SET;\n\t\t\t\tpropName = buffer;\n\t\t\t\tbuffer = '';\n\t\t\t}\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n\t\t\t\tcommit();\n\t\t\t\tif (mode === MODE_TAGNAME) {\n\t\t\t\t\tcurrent = current[0];\n\t\t\t\t}\n\t\t\t\tmode = current;\n\t\t\t\tif (MINI) {\n\t\t\t\t\t(current = current[0]).push(h.apply(null, mode.slice(1)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\n\t\t\t\t}\n\t\t\t\tmode = MODE_SLASH;\n\t\t\t}\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n\t\t\t\t// <a disabled>\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_WHITESPACE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer += char;\n\t\t\t}\n\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\n\t\t\t\tmode = MODE_COMMENT;\n\t\t\t\tcurrent = current[0];\n\t\t\t}\n\t\t}\n\t}\n\tcommit();\n\n\tif (MINI) {\n\t\treturn current.length > 2 ? current.slice(1) : current[1];\n\t}\n\treturn current;\n};\n","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MINI } from './constants.mjs';\nimport { build, evaluate } from './build.mjs';\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n\tlet tmp = CACHES.get(this);\n\tif (!tmp) {\n\t\ttmp = new Map();\n\t\tCACHES.set(this, tmp);\n\t}\n\ttmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n\treturn tmp.length > 1 ? tmp : tmp[0];\n};\n\nexport default MINI ? build : regular;\n","// From https://github.com/davidmarkclements/rfdc\n// This package currently doesn't work with es6 modules, so I need to copy the code here.\n\nfunction copyBuffer (cur) {\n\tif (cur instanceof Buffer) {\n\t\treturn Buffer.from(cur)\n\t}\n\n\treturn new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n\topts = opts || {}\n\n\tif (opts.circles) return rfdcCircles(opts)\n\treturn opts.proto ? cloneProto : clone\n\n\tfunction cloneArray (a, fn) {\n\t\tvar keys = Object.keys(a)\n\t\tvar a2 = new Array(keys.length)\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar k = keys[i]\n\t\t\tvar cur = a[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\ta2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\ta2[k] = new Date(cur)\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\ta2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\ta2[k] = fn(cur)\n\t\t\t}\n\t\t}\n\t\treturn a2\n\t}\n\n\tfunction clone (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, clone)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n\t\tvar o2 = {}\n\t\tfor (var k in o) {\n\t\t\tif (Object.hasOwnProperty.call(o, k) === false) continue\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\to2[k] = clone(cur)\n\t\t\t}\n\t\t}\n\t\treturn o2\n\t}\n\n\tfunction cloneProto (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, cloneProto)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n\t\tvar o2 = {}\n\t\tfor (var k in o) {\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\to2[k] = cloneProto(cur)\n\t\t\t}\n\t\t}\n\t\treturn o2\n\t}\n}\n\nfunction rfdcCircles (opts) {\n\tvar refs = []\n\tvar refsNew = []\n\n\treturn opts.proto ? cloneProto : clone\n\n\tfunction cloneArray (a, fn) {\n\t\tvar keys = Object.keys(a)\n\t\tvar a2 = new Array(keys.length)\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar k = keys[i]\n\t\t\tvar cur = a[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\ta2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\ta2[k] = new Date(cur)\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\ta2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar index = refs.indexOf(cur)\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\ta2[k] = refsNew[index]\n\t\t\t\t} else {\n\t\t\t\t\ta2[k] = fn(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn a2\n\t}\n\n\tfunction clone (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, clone)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n\t\tvar o2 = {}\n\t\trefs.push(o)\n\t\trefsNew.push(o2)\n\t\tfor (var k in o) {\n\t\t\tif (Object.hasOwnProperty.call(o, k) === false) continue\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar i = refs.indexOf(cur)\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\to2[k] = refsNew[i]\n\t\t\t\t} else {\n\t\t\t\t\to2[k] = clone(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trefs.pop()\n\t\trefsNew.pop()\n\t\treturn o2\n\t}\n\n\tfunction cloneProto (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, cloneProto)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n\t\tvar o2 = {}\n\t\trefs.push(o)\n\t\trefsNew.push(o2)\n\t\tfor (var k in o) {\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar i = refs.indexOf(cur)\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\to2[k] = refsNew[i]\n\t\t\t\t} else {\n\t\t\t\t\to2[k] = cloneProto(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trefs.pop()\n\t\trefsNew.pop()\n\t\treturn o2\n\t}\n}\n\nexport default rfdc()\n","import {RefuseFiber} from \"../render.js\";\n\nexport default function isChildfulFiber(fiber: any): fiber is RefuseFiber | HTMLElement {\n\treturn typeof fiber === 'object' && fiber !== null && 'child' in fiber;\n}\n","import {RefuseFiber} from \"../render.js\";\n\nexport default function isRefuseFiber(fiber: any): fiber is RefuseFiber {\n\treturn typeof fiber === 'object' && fiber !== null && 'type' in fiber && typeof fiber.type === 'function';\n}\n","// save the original methods before overwriting them\nElement.prototype._addEventListener = Element.prototype.addEventListener;\nElement.prototype._removeEventListener = Element.prototype.removeEventListener;\n\n/**\n * [addEventListener description]\n * @param {[type]}  type       [description]\n * @param {[type]}  listener   [description]\n * @param {Boolean} useCapture [description]\n */\nElement.prototype.addEventListener = function(type,listener,useCapture=false) {\n\t// declare listener\n\tthis._addEventListener(type,listener,useCapture);\n\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\tif(!this.eventListenerList[type]) this.eventListenerList[type] = [];\n\n\t// add listener to  event tracking list\n\tthis.eventListenerList[type].push( {type, listener, useCapture} );\n};\n\n/**\n * [removeEventListener description]\n * @param  {[type]}  type       [description]\n * @param  {[type]}  listener   [description]\n * @param  {Boolean} useCapture [description]\n * @return {[type]}             [description]\n */\nElement.prototype.removeEventListener = function(type,listener,useCapture=false) {\n\t// remove listener\n\tthis._removeEventListener(type,listener,useCapture);\n\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\tif(!this.eventListenerList[type]) this.eventListenerList[type] = [];\n\n\t// Find the event in the list, If a listener is registered twice, one\n\t// with capture and one without, remove each one separately. Removal of\n\t// a capturing listener does not affect a non-capturing version of the\n\t// same listener, and vice versa.\n\tfor(let i=0; i<this.eventListenerList[type].length; i++){\n\t\tif( this.eventListenerList[type][i].listener===listener && this.eventListenerList[type][i].useCapture===useCapture){\n\t\t\tthis.eventListenerList[type].splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if no more events of the removed event type are left,remove the group\n\tif(this.eventListenerList[type].length==0) delete this.eventListenerList[type];\n};\n\n\n/**\n * [getEventListeners description]\n * @param  {[type]} type [description]\n * @return {[type]}      [description]\n */\nElement.prototype.getEventListeners = function(type){\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\n\t// return requested listeners type or all them\n\tif(type===undefined)  return this.eventListenerList;\n\treturn this.eventListenerList[type];\n};\n","// @ts-ignore\nimport htm from '../node_modules/htm/src/index.mjs'\n// @ts-ignore\nimport clone from './utils/rfdc.js'\nimport isChildfulFiber from \"./utils/isChildfulFiber.js\";\nimport isRefuseFiber from \"./utils/isRefuseFiber.js\";\nimport {Ref} from \"./hooks.js\";\nimport './getEventListeners.js'\n\n//-----------------------------------------------------------------------------\n\ninterface HtmlFiber {\n\t// Data that use to create DOM element\n\trenderType?: string\n\trenderProps: Props\n\tchild: Fiber[]\n\tref?: Ref\n\tDOMNode?: Element | DocumentFragment\n}\n\nexport interface RefuseFiber extends HtmlFiber {\n\tisProcessed: boolean // Mark fiber as processed, processed fiber will not be process (to prevent children component to be processed multiple times)\n\tisDirty: boolean // Mark fiber as dirty, dirty fiber will be re-rendered\n\t// Data using to construct fiber\n\ttype: RefuseComponent\n\tprops: Props // Didn't include key and ref\n\t// Fiber state\n\tstate: any[]\n\tstateIndex: number\n\teffects: {\n\t\tdeps: unknown[] | undefined\n\t\tcallback: () => void | (() => void)\n\t\tcleanup: void | (() => void)\n\t\trun: boolean\n\t\tisLayout: boolean\n\t}[]\n\teffectIndex: number\n\tmemos: {\n\t\tdeps: unknown[] | undefined\n\t\tfactory: () => any\n\t\tvalue: any\n\t}[]\n\tmemoIndex: number\n}\n\ninterface Props {\n\t[key: string]: any\n}\n\nexport type Fiber = RefuseFiber | HtmlFiber | string | number | false | null | undefined\n\nexport type RefuseElement = Fiber | Fiber[] | RefuseElement[]\ntype Fuse = (strings: TemplateStringsArray, ...rest: any[]) => RefuseElement\nexport type RefuseComponent<T extends Props = Props> = (props: T, ref?: Ref) => RefuseElement\n\n// Utility types\n\nexport type ComponentProps<T extends RefuseComponent> = T extends (props: infer P, ...args: any[]) => ReturnType<T> ? P : never\nexport type ComponentRef<T extends RefuseComponent> = T extends (arg0: any, ref: infer P, ...args: any[]) => ReturnType<T> ? P : never\n\n//-----------------------------------------------------------------------------\n\nlet rootElement: Element | DocumentFragment,\n\trootComponent: RefuseComponent,\n\trootFiber: RefuseFiber,\n\tcurrentFiber: RefuseFiber // for hooks to access data\nlet batchUpdate: Function[] = []\nlet unmountedFibers: RefuseFiber[] = []\nlet batchUpdateTimer: {value: number | undefined} = {value: undefined}\n\nlet consoleLog = console.log\nif (ENV !== \"development\") {\n\t// Disable log in production\n\tconsoleLog = (...args: any) => {}\n}\nconst originalConsoleLog = consoleLog\n\n//-----------------------------------------------------------------------------\n\nfunction Fragment({children}: { children: RefuseFiber['child'] }) {\n\treturn children\n}\n\nfunction createDefaultRefuseFiber(\n\ttype: RefuseFiber['type'],\n\tprops?: RefuseFiber[\"props\"],\n\tchild?: RefuseFiber['child'],\n\tref?: Ref\n): RefuseFiber {\n\treturn {\n\t\tref: ref,\n\t\ttype: type,\n\t\tprops: props ?? {},\n\t\tchild: child ?? [],\n\t\tisProcessed: false,\n\t\tisDirty: true,\n\t\tstate: [],\n\t\tstateIndex: 0,\n\t\teffects: [],\n\t\teffectIndex: 0,\n\t\tmemos: [],\n\t\tmemoIndex: 0,\n\t\trenderType: undefined,\n\t\trenderProps: {},\n\t}\n}\n\nfunction throwElementError(...args: any[]) {\n\tthrow new Error(...args)\n}\n\nfunction createElement(type: any, props: any, ...child: any[]): Fiber {\n\t// @ts-ignore\n\t// this[0] = 3 // disable cache\n\n\tconst ref = props?.ref\n\tdelete props?.ref\n\n\tif (typeof type === 'function') { // Capturing phase\n\t\treturn createDefaultRefuseFiber(type, props, child, ref)\n\t} else {\n\n\t\tif (typeof type !== 'string') {\n\t\t\tthrowElementError('Invalid element type, required string, received ' + typeof type + ' instead: ' + JSON.stringify(type) + '.')\n\t\t}\n\n\t\tif (!props) {\n\t\t\tprops = {}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols(props).length > 0) {\n\t\t\tthrowElementError('Invalid element prop name in '+type+', we don\\'t support for symbol prop name, please try another primitive.')\n\t\t}\n\n\t\tfor (const prop of Object.values(props)) {\n\t\t\tif (typeof prop !== 'string' && typeof prop !== 'number' && typeof prop !== 'function') {\n\t\t\t\tthrowElementError('Invalid element prop value in ' + type + ', we only support for string, number and function prop value.')\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tref: ref,\n\t\t\trenderType: type,\n\t\t\trenderProps: props ?? {},\n\t\t\tchild: child,\n\t\t}\n\t}\n}\n\nconst fuse: Fuse = htm.bind(createElement)\n\nfunction markAsUnmounted(fiber: Fiber | string | number) {\n\tif (typeof fiber !== 'number' && typeof fiber !== 'string' && isRefuseFiber(fiber)) {\n\t\tunmountedFibers.push(fiber)\n\t}\n}\n\nfunction* getNextRefuseFiberInChild(fiber: Fiber): Generator<[RefuseFiber['child'], number]> {\n\tif (Array.isArray(fiber)) {\n\t\tfor (const i in fiber) {\n\t\t\tif (isRefuseFiber(fiber[i])) {\n\t\t\t\tyield [fiber, i as unknown as number]\n\t\t\t} else {\n\t\t\t\tfor (let j of getNextRefuseFiberInChild(fiber[i])) {\n\t\t\t\t\tyield j\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (isChildfulFiber(fiber)) {\n\t\tfor (const i in fiber.child) {\n\t\t\tif (isRefuseFiber(fiber.child[i])) {\n\t\t\t\t// TODO: fix this cast, i don't know why typescript tell i is a string\n\t\t\t\tyield [fiber.child, i as unknown as number]\n\t\t\t} else {\n\t\t\t\tfor (let j of getNextRefuseFiberInChild(fiber.child[i])) {\n\t\t\t\t\tyield j\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction addComponentToElement(fiber: Fiber, oldFiber: Fiber, element: Element | DocumentFragment) {\n\tif (Array.isArray(fiber)) {\n\t\tfiber.forEach((c, i) => {\n\t\t\tlet oldFiberChild\n\t\t\tif (typeof oldFiber !== \"string\" && typeof oldFiber !== \"number\" && oldFiber && oldFiber.DOMNode) {\n\t\t\t\tif (Array.isArray(oldFiber)) {\n\t\t\t\t\toldFiberChild = oldFiber[i]\n\t\t\t\t} else {\n\t\t\t\t\toldFiberChild = oldFiber.child[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\taddComponentToElement(c, oldFiberChild, element)\n\t\t})\n\t} else {\n\t\tif (fiber !== false && fiber !== null && fiber !== undefined) {\n\t\t\tif (fiber && typeof fiber !== \"string\" && typeof fiber !== \"number\") {\n\t\t\t\tif (!isRefuseFiber(fiber)) { // If this is a refuse fiber, we already process it\n\t\t\t\t\tlet oldChild\n\t\t\t\t\tif (typeof oldFiber !== \"string\" && typeof oldFiber !== \"number\" && oldFiber && oldFiber.DOMNode) {\n\t\t\t\t\t\tfiber.DOMNode = oldFiber.DOMNode\n\t\t\t\t\t\toldChild = oldFiber.child\n\t\t\t\t\t}\n\t\t\t\t\ttoDOMElement(fiber, oldChild)\n\t\t\t\t}\n\t\t\t\telement.appendChild(fiber.DOMNode!)\n\t\t\t} else {\n\t\t\t\telement.appendChild(document.createTextNode(String(fiber)))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction toDOMElement(fiber: HtmlFiber | RefuseFiber, oldChild: HtmlFiber['child'] | undefined) {\n\n\tif (\"isProcessed\" in fiber && fiber.isProcessed) {\n\t\treturn\n\t} else {\n\n\t\tlet element: Element | DocumentFragment = new DocumentFragment()\n\n\t\tif (fiber.renderType !== undefined) {\n\n\t\t\tlet attributes: Record<string, any> = {},\n\t\t\t\tevents: Record<string, any> = {}\n\n\t\t\tfor (let key in fiber.renderProps) {\n\t\t\t\tif (![null, undefined, false].includes(fiber.renderProps[key])) {\n\t\t\t\t\tif (typeof fiber.renderProps[key] !== \"function\") {\n\t\t\t\t\t\tattributes[key] = fiber.renderProps[key]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevents[key.slice(2)] = fiber.renderProps[key] // remove first 2 characters of attribute name (which is \"on\") to make it a valid event name then add it to the element\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fiber?.DOMNode && fiber.DOMNode instanceof Element && fiber.DOMNode.tagName.toLowerCase() === fiber.renderType) {\n\t\t\t\t// Reuse oldFiber.DOMNode\n\t\t\t\telement = fiber.DOMNode\n\n\t\t\t\tfor (const attr of fiber.DOMNode.attributes) {\n\t\t\t\t\tif (!(attr.name in attributes)) {\n\t\t\t\t\t\telement.removeAttribute(attr.name)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst oldEvents: Record<string, any[]> = element.getEventListeners()\n\n\t\t\t\tfor (const eventName in oldEvents) {\n\t\t\t\t\toldEvents[eventName].forEach(event => {\n\t\t\t\t\t\telement.removeEventListener(eventName, event.listener)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\twhile (element.firstChild) {\n\t\t\t\t\telement.removeChild(element.firstChild);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// Init new DOMNode\n\t\t\t\telement = document.createElement(fiber.renderType)\n\t\t\t}\n\n\t\t\tfor (let key in attributes) {\n\t\t\t\telement.setAttribute(key, attributes[key])\n\t\t\t}\n\n\t\t\tfor (let key in events) {\n\t\t\t\telement.addEventListener(key, events[key])\n\t\t\t}\n\n\t\t\tif (fiber?.ref) {\n\t\t\t\tfiber.ref.current = element\n\t\t\t}\n\t\t}\n\n\t\tfiber.DOMNode = element\n\t}\n\n\tfiber.child.forEach((child, index) => {\n\t\taddComponentToElement(child, oldChild?.[index], fiber.DOMNode!)\n\t})\n}\n\n\nfunction reconcileChild(parentFiberIsDirty: boolean, oldChild: RefuseFiber['child'] | undefined, child: RefuseFiber['child'], DOMNode: Exclude<RefuseFiber['DOMNode'], undefined>) {\n\t// TODO: match key-ed child\n\tfor (const i in child) {\n\t\tif (typeof child[i] !== 'number' && typeof child[i] !== 'string') {\n\t\t\tif (\n\t\t\t\t(isRefuseFiber(child[i]) && parentFiberIsDirty) || // If there are some component passed as child to this child (only happen when parent is dirty)\n\t\t\t\tArray.isArray(child[i]) ||// If the child is an array\n\t\t\t\t!isRefuseFiber(child[i]) // If the child is html fiber, it can still contain refuse fiber deep inside it\n\t\t\t) {\n\t\t\t\tconst nextOldChild = getNextRefuseFiberInChild(oldChild?.[i])\n\t\t\t\tconst nextChild = getNextRefuseFiberInChild(child[i])\n\t\t\t\t// Iterate in indirect child\n\t\t\t\tfor (const j of nextChild) {\n\t\t\t\t\tconst oldChildNext = nextOldChild.next().value\n\t\t\t\t\tj[0][j[1]] = reconcile(parentFiberIsDirty, oldChildNext?.[0]?.[oldChildNext[1]], j[0][j[1]] as RefuseFiber) // result getNextRefuseFiberInChild will always be RefuseFiber\n\t\t\t\t}\n\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tfor (const j of nextOldChild) {\n\t\t\t\t\tmarkAsUnmounted(j[0][j[1]])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRefuseFiber(child[i])) {\n\t\t\t\t// Then we can reconcile the child itself\n\t\t\t\tchild[i] = reconcile(\n\t\t\t\t\tparentFiberIsDirty,\n\t\t\t\t\t// @ts-expect-error Somehow type-guard is not working here\n\t\t\t\t\tisRefuseFiber(oldChild?.[i]) ? oldChild[i] : undefined,\n\t\t\t\t\tchild[i]\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(child[i])) {\n\t\t\t\t\t// consoleLog('---------array of fiber', clone(child[i]), clone(oldChild?.[i]))\n\t\t\t\t} else {\n\t\t\t\t\t// consoleLog('---------html fiber', clone(child[i]), clone(oldChild?.[i]))\n\t\t\t\t}\n\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tif (isRefuseFiber(oldChild?.[i])) {\n\t\t\t\t\tmarkAsUnmounted(oldChild?.[i])\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\t// child[i] is number or string\n\n\t\t\tif (oldChild?.[i] !== child[i]) {\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tif (isRefuseFiber(oldChild?.[i])) {\n\t\t\t\t\tmarkAsUnmounted(oldChild?.[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction reconcile(parentFiberIsDirty: boolean | undefined, oldFiber: RefuseFiber | undefined, fiber: RefuseFiber): RefuseFiber {\n\n\tif (fiber.isProcessed) return fiber\n\n\tconst oldChild = oldFiber?.child\n\n\tif (fiber.type !== Fragment) {\n\n\t\tlet isReuse = false\n\n\t\tif (oldFiber) {\n\t\t\tif (oldFiber.type === fiber.type) {\n\t\t\t\t// consoleLog('Reuse:', clone(oldFiber))\n\t\t\t\tisReuse = true\n\t\t\t\tfiber.isDirty = oldFiber.isDirty\n\t\t\t} else {\n\t\t\t\tmarkAsUnmounted(oldFiber)\n\t\t\t}\n\t\t}\n\n\t\tfiber.isDirty = parentFiberIsDirty || fiber.isDirty\n\n\t\tif (fiber.isDirty) {\n\t\t\tconsoleLog(fiber.type.name, 'is dirty')\n\n\t\t\tlet newProps = fiber.props\n\t\t\tconst newRef = fiber.ref\n\n\t\t\tif (parentFiberIsDirty) { // If parent fiber is dirty, then props probably changed\n\t\t\t\t// Save the reference to new props and children so set it later\n\t\t\t\tnewProps = {...fiber.props, children: fiber.child ?? []}\n\t\t\t}\n\n\t\t\tif (isReuse) {\n\t\t\t\tfiber = oldFiber as RefuseFiber // If isReuse then oldFiber is RefuseFiber\n\t\t\t}\n\n\t\t\t// Save props\n\t\t\tfiber.props = newProps\n\t\t\tfiber.ref = newRef\n\n\t\t\tcurrentFiber = fiber\n\t\t\tconst result = fiber.type({...fiber.props}, fiber.ref)\n\n\t\t\tif (result === undefined || result === false || result === null) {\n\t\t\t\t// Stop reconcile child if result is undefined, null, false, empty array\n\t\t\t\tfiber.child = []\n\t\t\t} else if (Array.isArray(result)) {\n\t\t\t\t// Array of text, string\n\t\t\t\tfiber.child = result as RefuseFiber['child'] // TODO: investigate how to eliminate this type cast\n\t\t\t} else if (typeof result !== 'object' || (isRefuseFiber(result) && result.type !== fiber.type)) {\n\t\t\t\tfiber.child = [result]\n\t\t\t} else {\n\t\t\t\tfiber.renderType = result.renderType\n\t\t\t\tfiber.renderProps = result.renderProps\n\t\t\t\tfiber.child = result.child\n\t\t\t}\n\t\t\tconsoleLog('Result:', fiber.type.name, clone(fiber)) // No child state\n\t\t} else {\n\t\t\tconsoleLog(fiber.type.name, 'is clean')\n\t\t\tif (isReuse) {\n\t\t\t\tfiber = oldFiber as RefuseFiber // If isReuse then oldFiber is RefuseFiber\n\t\t\t}\n\t\t}\n\t}\n\n\treconcileChild(\"isDirty\" in fiber ? fiber.isDirty : false, oldChild, fiber.child, fiber.DOMNode!)\n\tconsoleLog('DONE: ', fiber.type.name, clone(fiber))\n\ttoDOMElement(fiber, oldChild)\n\tfiber.isProcessed = true\n\n\treturn fiber\n}\n\nfunction resetFiber(fiber: Fiber | Fiber[]) {\n\tif (typeof fiber === \"object\" && fiber) {\n\t\tif (!Array.isArray(fiber)) {\n\t\t\tif (isRefuseFiber(fiber)) {\n\t\t\t\tfiber.stateIndex = 0\n\t\t\t\tfiber.effectIndex = 0\n\t\t\t\tfiber.memoIndex = 0\n\t\t\t\tfiber.isDirty = false\n\t\t\t\tfiber.isProcessed = false\n\t\t\t}\n\n\t\t\tfiber.child.forEach(f => {\n\t\t\t\tif (typeof f === \"object\") {\n\t\t\t\t\tresetFiber(f)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tfiber.forEach(f => resetFiber(f))\n\t\t}\n\t}\n}\n\nfunction runEffects(fiber: Fiber, isLayout = false) {\n\t// Called in a bottom-up fashion, run children's effects first\n\tif (typeof fiber === \"string\" || typeof fiber === \"number\" || !fiber) return\n\n\tfiber.child.forEach(child => {\n\t\tif (Array.isArray(child)) {\n\t\t\tchild.forEach(c => runEffects(c, isLayout))\n\t\t} else {\n\t\t\trunEffects(child, isLayout)\n\t\t}\n\t})\n\n\tif (isRefuseFiber(fiber)) {\n\t\tfor (let i = 0; i < fiber.effects.length; i++) {\n\t\t\tif (fiber.effects[i].run && fiber.effects[i].isLayout === isLayout) {\n\t\t\t\tfiber.effects[i].cleanup?.()\n\t\t\t\tfiber.effects[i].cleanup = fiber.effects[i].callback()\n\t\t\t\tfiber.effects[i].run = false\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction cleanUpEffects(fiber: Fiber) {\n\t// Called in a bottom-up fashion, run children's effects first\n\tif (typeof fiber === \"string\" || typeof fiber === \"number\" || !fiber) return\n\n\tfiber.child.forEach(child => {\n\t\tif (Array.isArray(child)) {\n\t\t\tchild.forEach(c => cleanUpEffects(c))\n\t\t} else {\n\t\t\tcleanUpEffects(child)\n\t\t}\n\t})\n\n\tif (isRefuseFiber(fiber)) {\n\t\tfor (let i = 0; i < fiber.effects.length; i++) {\n\t\t\tfiber.effects[i].cleanup?.()\n\t\t}\n\t}\n}\n\nfunction rerender() {\n\tconsoleLog('----------------------------------------------------------------')\n\t// Batch update state changes\n\tconsoleLog('@@@@@@@ Batch updating...')\n\tconsoleLog = (...args) => originalConsoleLog('[State change]', ...args)\n\n\twhile (batchUpdate.length) {\n\t\tbatchUpdate.pop()!()\n\t}\n\tconsoleLog = originalConsoleLog\n\n\t// Render phase, and schedule effects to run later\n\tconsoleLog('@@@@@@@ Rendering...')\n\t// consoleLog = (...args) => originalConsoleLog('[Render]', ...args)\n\tconst newRootFiber= reconcile(undefined, rootFiber, createDefaultRefuseFiber(rootComponent))\n\tresetFiber(newRootFiber) // Reset fiber to prepare for next render\n\tconsoleLog('Result:', newRootFiber)\n\t// consoleLog = originalConsoleLog\n\n\t// Reconciliation phase: tree diffing: find out what changed, what component to mount and to unmount\n\t// https://reactjs.org/docs/reconciliation.html\n\n\t// Commit phase: commit changes to real DOM\n\trootElement.textContent = ''\n\trootElement.appendChild(newRootFiber.DOMNode!)\n\trootFiber = newRootFiber\n\t// newRootFiber.DOMNode = toDOMNode(newRootFiber, rootFiber?.DOMNode)\n\t// if (newRootFiber.DOMNode !== rootFiber?.DOMNode) {\n\t// \trootElement.textContent = ''\n\t// \trootElement.appendChild(newRootFiber.DOMNode!)\n\t// \trootFiber = newRootFiber\n\t// }\n\n\t// Layout Effects goes here and block browser paint\n\t// After running all layout effects at once, if changes are made, trigger re-render again before browser paint\n\t// using requestAnimationFrame\n\tconst channel = new MessageChannel()\n\n\tfunction runEffectsFunc() {\n\t\t// Run effects and cleanup effects of unmounted components\n\t\t// 1: if changes are made in layout effects: run before browser paint\n\t\t// 2: if no changes are made in layout effects: run after browser painted to the screen\n\t\tconsoleLog('@@@@@@ Running effects...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Effect]', ...args)\n\t\trunEffects(rootFiber)\n\t\tconsoleLog = originalConsoleLog\n\n\t\t// Clean up unmounted components last\n\t\tconsoleLog('@@@@@@ Cleaning up unmounted components...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Effect cleanup]', ...args)\n\t\twhile (unmountedFibers.length) {\n\t\t\tcleanUpEffects(unmountedFibers.pop()!)\n\t\t}\n\t\tconsoleLog = originalConsoleLog\n\t}\n\n\trequestAnimationFrame(function () {\n\n\t\tconsoleLog('@@@@@@ Running layout effects before repaint...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Layout effect]', ...args)\n\t\trunEffects(rootFiber, true)\n\t\tconsoleLog = originalConsoleLog\n\n\t\tif (batchUpdate.length) {\n\t\t\trunEffectsFunc()\n\t\t\tclearTimeout(batchUpdateTimer.value)\n\t\t\trerender()\n\t\t} else {\n\t\t\tchannel.port1.onmessage = runEffectsFunc\n\t\t\tchannel.port2.postMessage(undefined) // Guarantee to postMessage after paint\n\t\t\tconsoleLog('@@@@@@ Browser painted to the screen')\n\t\t}\n\t})\n}\n\nfunction render(component: RefuseComponent, element: Element | null) {\n\tif (element) {\n\t\trootElement = element\n\t} else {\n\t\trootElement = document.createDocumentFragment()\n\t\tdocument.body.prepend(rootElement)\n\t}\n\n\trootComponent = component\n\n\trerender()\n}\n\nexport {\n\trender,\n\tfuse,\n\tFragment,\n\tcurrentFiber,\n\tbatchUpdate,\n\tbatchUpdateTimer,\n\trerender\n}\n","import type {ComponentProps, ComponentRef, RefuseComponent, RefuseFiber} from \"./render.js\";\nimport {batchUpdate, batchUpdateTimer, currentFiber, rerender} from \"./render.js\";\n\nexport function useState<T = Exclude<unknown, Function>>(initialValue: T): [T, (newValue: T | ((prevState: T) => T)) => void] {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.stateIndex++ // this change overtime too\n\n\tthisFiber.state[thisIndex] ??= initialValue\n\n\tfunction setState(newState:  T | ((prevState: T) => T)) {\n\t\tif (!batchUpdate.length) batchUpdateTimer.value = setTimeout(rerender, 0)\n\n\t\tbatchUpdate.push(function() {\n\n\t\t\tif (typeof newState === 'function') {\n\t\t\t\tnewState = (newState as (newValue: T) => T)(thisFiber.state[thisIndex])\n\t\t\t}\n\n\t\t\tif (thisFiber.state[thisIndex] !== newState) {\n\t\t\t\tconsole.log('Update from', thisFiber.state[thisIndex], 'to', newState, 'in', thisFiber.type.name)\n\t\t\t\tthisFiber.state[thisIndex] = newState\n\t\t\t\tthisFiber.isDirty = true\n\t\t\t}\n\t\t})\n\t}\n\n\treturn [thisFiber.state[thisIndex], setState]\n}\n\ntype effectCallback = () => (() => void) | void\n\nexport function useEffect(callback: effectCallback, deps: RefuseFiber['effects'][number]['deps'], isLayout = false) {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.effectIndex++ // this change overtime too\n\n\tlet run = false\n\n\t// No dependency, run every rerender\n\tif (!deps) {\n\t\trun = true\n\t}\n\t// Has dependency, run if dependency changed\n\telse if (!thisFiber.effects[thisIndex] || deps.length !== thisFiber.effects[thisIndex].deps?.length\n\t\t|| deps.some((dep, i) => dep !== thisFiber.effects[thisIndex].deps?.[i])) {\n\t\trun = true\n\t}\n\n\tif (run) {\n\t\tthisFiber.effects[thisIndex] = {\n\t\t\t...thisFiber.effects[thisIndex],\n\t\t\tdeps,\n\t\t\tcallback,\n\t\t\trun,\n\t\t\tisLayout,\n\t\t}\n\t}\n}\n\nexport const useLayoutEffect = (callback: effectCallback, deps: RefuseFiber['effects'][number]['deps']) => useEffect(callback, deps, true)\n\nexport function useMemo<T>(factory: () => T, deps: RefuseFiber['memos'][number]['deps']): T {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.memoIndex++ // this change overtime too\n\n\tlet update = false\n\n\t// No dependency, run every rerender\n\tif (!deps) {\n\t\tupdate = true\n\t}\n\t// Has dependency, run if dependency changed\n\telse if (!thisFiber.memos[thisIndex] || deps.length !== thisFiber.memos[thisIndex].deps?.length\n\t\t|| deps.some((dep, i) => dep !== thisFiber.memos[thisIndex].deps?.[i])) {\n\t\tupdate = true\n\t}\n\n\tif (update) {\n\t\tthisFiber.memos[thisIndex] = {\n\t\t\t...thisFiber.memos[thisIndex],\n\t\t\tdeps,\n\t\t\tfactory,\n\t\t\tvalue: factory(),\n\t\t}\n\t}\n\n\treturn thisFiber.memos[thisIndex].value\n}\n\nexport function useCallback<T = any>(callback: T, deps: any[]): T {\n\treturn useMemo(() => callback, deps)\n}\n\nexport type Ref<T = any> = {\n\tcurrent: T | null\n}\n\nexport function useRef<T = any>(initialValue: T): Ref<T> {\n\treturn useMemo(() => ({ current: initialValue }), [])\n}\n\nfunction shallowEqual<T extends Record<string, any>>(prevProps: T | null, nextProps: T): boolean {\n\tif (prevProps === null) return false\n\n\tconst prevKeys = Object.keys(prevProps)\n\tconst nextKeys = Object.keys(nextProps)\n\n\tif (prevKeys.length !== nextKeys.length) return false\n\tif (prevKeys.length === 0) return true\n\n\tfor (let i = 0; i < prevKeys.length; i++) {\n\t\tif (prevKeys[i] !== 'children' && prevProps[prevKeys[i]] !== nextProps[prevKeys[i]]) return false\n\t}\n\n\treturn shallowEqual(prevProps.children, nextProps.children)\n}\n\nexport function memo<T extends RefuseComponent = RefuseComponent>(component: T, areEqual: ((prevProps: ComponentProps<T> | null, nextProps: ComponentProps<T>) => boolean) = shallowEqual<ComponentProps<T>>) {\n\tconst memoComponent = function(props: ComponentProps<T>, ref: ComponentRef<T>) {\n\t\tconst prevProps = useRef<ComponentProps<T> | null>(null)\n\t\tuseEffect(() => {\n\t\t\tprevProps.current = props\n\t\t}, [props])\n\t\tconsole.log('[Memo check]', areEqual(prevProps.current, props), prevProps.current, props)\n\n\t\treturn areEqual(prevProps.current, props) ? currentFiber : component(props, ref)\n\t}\n\n\t// Name the memo component for debugging purpose\n\tObject.defineProperty(memoComponent, 'name', {value: component.name, writable: false});\n\treturn memoComponent\n}\n"],"names":["evaluate","h","built","fields","args","tmp","i","length","type","value","Object","assign","apply","push","build","statics","char","propName","mode","buffer","quote","current","commit","field","replace","j","CACHES","Map","cur","Buffer","from","constructor","slice","byteOffset","clone","opts","circles","refs","proto","cloneProto","o","Date","Array","isArray","cloneArray","Set","o2","refsNew","k","ArrayBuffer","isView","copyBuffer","indexOf","pop","hasOwnProperty","call","a","fn","keys","a2","index","rfdcCircles","isChildfulFiber","fiber","isRefuseFiber","Element","prototype","_addEventListener","addEventListener","_removeEventListener","removeEventListener","listener","useCapture","this","eventListenerList","splice","getEventListeners","undefined","getNextRefuseFiberInChild","rootElement","rootComponent","rootFiber","currentFiber","batchUpdate","unmountedFibers","batchUpdateTimer","consoleLog","console","log","originalConsoleLog","Fragment","_ref","children","createDefaultRefuseFiber","props","child","ref","isProcessed","isDirty","state","stateIndex","effects","effectIndex","memos","memoIndex","renderType","renderProps","throwElementError","Error","arguments","fuse","get","set","bind","_props3","_props","_props2","JSON","stringify","getOwnPropertySymbols","_i","_Object$values","values","prop","markAsUnmounted","_iterator","_step","_i2","_iterator2","_step2","_j","_regeneratorRuntime","wrap","_context","prev","next","t1","t0","done","t3","t2","stop","_marked","addComponentToElement","oldFiber","element","forEach","c","oldFiberChild","DOMNode","oldChild","toDOMElement","appendChild","document","createTextNode","String","DocumentFragment","attributes","events","key","includes","tagName","toLowerCase","attr","_step3","name","removeAttribute","oldEvents","eventName","event","firstChild","removeChild","createElement","_key","setAttribute","reconcile","parentFiberIsDirty","isReuse","newProps","_extends","_fiber$child","newRef","result","_step4","nextOldChild","_iterator4","_createForOfIteratorHelperLoose","oldChildNext","_oldChildNext$","_step5","_iterator5","_j2","reconcileChild","resetFiber","f","isLayout","runEffects","_fiber$effects$i$clea","_fiber$effects$i","run","cleanup","callback","cleanUpEffects","_fiber$effects$i$clea2","_fiber$effects$i2","rerender","concat","newRootFiber","textContent","channel","MessageChannel","requestAnimationFrame","runEffectsFunc","clearTimeout","port1","onmessage","port2","postMessage","render","component","createDocumentFragment","body","prepend","useState","initialValue","_thisFiber$state","thisFiber","thisIndex","newState","setTimeout","useEffect","deps","_thisFiber$effects$th","some","dep","_thisFiber$effects$th2","useLayoutEffect","factory","_thisFiber$memos$this","update","_thisFiber$memos$this2","useCallback","useMemo","useRef","prevProps","nextProps","nextKeys","prevKeys","memo","areEqual","shallowEqual","memoComponent","defineProperty","writable"],"mappings":"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"}