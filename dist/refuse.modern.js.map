{"version":3,"file":"refuse.modern.js","sources":["../node_modules/htm/src/build.mjs","../node_modules/htm/src/index.mjs","../src/utils/rfdc.js","../src/utils/isRefuseFiber.ts","../src/render.ts","../src/getEventListeners.js","../src/utils/isChildfulFiber.ts","../src/hooks.ts"],"sourcesContent":["import { MINI } from './constants.mjs';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst TAG_SET = 3;\nconst PROPS_ASSIGN = 4;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n// \ttreeify(\n//\t\tbuild`<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//\t\t[X, Y, Z]\n//\t)\n// returns:\n// \t{\n// \t\ttag: 'div',\n//\t\tprops: [ { href: [\"1\", X] }, Y ],\n// \t\tchildren: [ { tag: Z, props: [], children: [] } ]\n// \t}\nexport const treeify = (built, fields) => {\n\tconst _treeify = built => {\n\t\tlet tag = '';\n\t\tlet currentProps = null;\n\t\tconst props = [];\n\t\tconst children = [];\n\n\t\tfor (let i = 1; i < built.length; i++) {\n\t\t\tconst type = built[i++];\n\t\t\tconst value = built[i] ? fields[built[i++]-1] : built[++i];\n\n\t\t\tif (type === TAG_SET) {\n\t\t\t\ttag = value;\n\t\t\t}\n\t\t\telse if (type === PROPS_ASSIGN) {\n\t\t\t\tprops.push(value);\n\t\t\t\tcurrentProps = null;\n\t\t\t}\n\t\t\telse if (type === PROP_SET) {\n\t\t\t\tif (!currentProps) {\n\t\t\t\t\tcurrentProps = Object.create(null);\n\t\t\t\t\tprops.push(currentProps);\n\t\t\t\t}\n\t\t\t\tcurrentProps[built[++i]] = [value];\n\t\t\t}\n\t\t\telse if (type === PROP_APPEND) {\n\t\t\t\tcurrentProps[built[++i]].push(value);\n\t\t\t}\n\t\t\telse if (type === CHILD_RECURSE) {\n\t\t\t\tchildren.push(_treeify(value));\n\t\t\t}\n\t\t\telse if (type === CHILD_APPEND) {\n\t\t\t\tchildren.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn { tag, props, children };\n\t};\n\tconst { children } = _treeify(built);\n\treturn children.length > 1 ? children : children[0];\n};\n\nexport const evaluate = (h, built, fields, args) => {\n\tlet tmp;\n\n\t// `build()` used the first element of the operation list as\n\t// temporary workspace. Now that `build()` is done we can use\n\t// that space to track whether the current element is \"dynamic\"\n\t// (i.e. it or any of its descendants depend on dynamic values).\n\tbuilt[0] = 0;\n\n\tfor (let i = 1; i < built.length; i++) {\n\t\tconst type = built[i++];\n\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\n\n\t\tif (type === TAG_SET) {\n\t\t\targs[0] = value;\n\t\t}\n\t\telse if (type === PROPS_ASSIGN) {\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\n\t\t}\n\t\telse if (type === PROP_SET) {\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\n\t\t}\n\t\telse if (type === PROP_APPEND) {\n\t\t\targs[1][built[++i]] += (value + '');\n\t\t}\n\t\telse if (type) { // type === CHILD_RECURSE\n\t\t\t// Set the operation list (including the staticness bits) as\n\t\t\t// `this` for the `h` call.\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\n\t\t\targs.push(tmp);\n\n\t\t\tif (value[0]) {\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\n\t\t\t\tbuilt[0] |= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\n\t\t\t\t// Essentially the operation list gets optimized for potential future\n\t\t\t\t// re-evaluations.\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\n\t\t\t\tbuilt[i] = tmp;\n\t\t\t}\n\t\t}\n\t\telse { // type === CHILD_APPEND\n\t\t\targs.push(value);\n\t\t}\n\t}\n\n\treturn args;\n};\n\nexport const build = function(statics) {\n\tconst fields = arguments;\n\tconst h = this;\n\n\tlet mode = MODE_TEXT;\n\tlet buffer = '';\n\tlet quote = '';\n\tlet current = [0];\n\tlet char, propName;\n\n\tconst commit = field => {\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent.push(field ? fields[field] : buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[1] = field ? fields[field] : buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\n\t\t\t}\n\t\t\tmode = MODE_WHITESPACE;\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[2] = Object.assign(current[2] || {}, fields[field]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\n\t\t\tif (MINI) {\n\t\t\t\t(current[2] = current[2] || {})[buffer] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode >= MODE_PROP_SET) {\n\t\t\tif (MINI) {\n\t\t\t\tif (mode === MODE_PROP_SET) {\n\t\t\t\t\t(current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\telse if (field || buffer) {\n\t\t\t\t\tcurrent[2][propName] += field ? buffer + fields[field] : buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\tif (field) {\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuffer = '';\n\t};\n\n\tfor (let i=0; i<statics.length; i++) {\n\t\tif (i) {\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t\tcommit(i);\n\t\t}\n\n\t\tfor (let j=0; j<statics[i].length;j++) {\n\t\t\tchar = statics[i][j];\n\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tif (char === '<') {\n\t\t\t\t\t// commit buffer\n\t\t\t\t\tcommit();\n\t\t\t\t\tif (MINI) {\n\t\t\t\t\t\tcurrent = [current, '', null];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcurrent = [current];\n\t\t\t\t\t}\n\t\t\t\t\tmode = MODE_TAGNAME;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode === MODE_COMMENT) {\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\n\t\t\t\tif (buffer === '--' && char === '>') {\n\t\t\t\t\tmode = MODE_TEXT;\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = char + buffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (quote) {\n\t\t\t\tif (char === quote) {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (char === '\"' || char === \"'\") {\n\t\t\t\tquote = char;\n\t\t\t}\n\t\t\telse if (char === '>') {\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_TEXT;\n\t\t\t}\n\t\t\telse if (!mode) {\n\t\t\t\t// Ignore everything until the tag ends\n\t\t\t}\n\t\t\telse if (char === '=') {\n\t\t\t\tmode = MODE_PROP_SET;\n\t\t\t\tpropName = buffer;\n\t\t\t\tbuffer = '';\n\t\t\t}\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n\t\t\t\tcommit();\n\t\t\t\tif (mode === MODE_TAGNAME) {\n\t\t\t\t\tcurrent = current[0];\n\t\t\t\t}\n\t\t\t\tmode = current;\n\t\t\t\tif (MINI) {\n\t\t\t\t\t(current = current[0]).push(h.apply(null, mode.slice(1)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\n\t\t\t\t}\n\t\t\t\tmode = MODE_SLASH;\n\t\t\t}\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n\t\t\t\t// <a disabled>\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_WHITESPACE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer += char;\n\t\t\t}\n\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\n\t\t\t\tmode = MODE_COMMENT;\n\t\t\t\tcurrent = current[0];\n\t\t\t}\n\t\t}\n\t}\n\tcommit();\n\n\tif (MINI) {\n\t\treturn current.length > 2 ? current.slice(1) : current[1];\n\t}\n\treturn current;\n};\n","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MINI } from './constants.mjs';\nimport { build, evaluate } from './build.mjs';\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n\tlet tmp = CACHES.get(this);\n\tif (!tmp) {\n\t\ttmp = new Map();\n\t\tCACHES.set(this, tmp);\n\t}\n\ttmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n\treturn tmp.length > 1 ? tmp : tmp[0];\n};\n\nexport default MINI ? build : regular;\n","// From https://github.com/davidmarkclements/rfdc\n// This package currently doesn't work with es6 modules, so I need to copy the code here.\n\nfunction copyBuffer (cur) {\n\tif (cur instanceof Buffer) {\n\t\treturn Buffer.from(cur)\n\t}\n\n\treturn new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n\topts = opts || {}\n\n\tif (opts.circles) return rfdcCircles(opts)\n\treturn opts.proto ? cloneProto : clone\n\n\tfunction cloneArray (a, fn) {\n\t\tvar keys = Object.keys(a)\n\t\tvar a2 = new Array(keys.length)\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar k = keys[i]\n\t\t\tvar cur = a[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\ta2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\ta2[k] = new Date(cur)\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\ta2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\ta2[k] = fn(cur)\n\t\t\t}\n\t\t}\n\t\treturn a2\n\t}\n\n\tfunction clone (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, clone)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n\t\tvar o2 = {}\n\t\tfor (var k in o) {\n\t\t\tif (Object.hasOwnProperty.call(o, k) === false) continue\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\to2[k] = clone(cur)\n\t\t\t}\n\t\t}\n\t\treturn o2\n\t}\n\n\tfunction cloneProto (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, cloneProto)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n\t\tvar o2 = {}\n\t\tfor (var k in o) {\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\to2[k] = cloneProto(cur)\n\t\t\t}\n\t\t}\n\t\treturn o2\n\t}\n}\n\nfunction rfdcCircles (opts) {\n\tvar refs = []\n\tvar refsNew = []\n\n\treturn opts.proto ? cloneProto : clone\n\n\tfunction cloneArray (a, fn) {\n\t\tvar keys = Object.keys(a)\n\t\tvar a2 = new Array(keys.length)\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar k = keys[i]\n\t\t\tvar cur = a[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\ta2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\ta2[k] = new Date(cur)\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\ta2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar index = refs.indexOf(cur)\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\ta2[k] = refsNew[index]\n\t\t\t\t} else {\n\t\t\t\t\ta2[k] = fn(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn a2\n\t}\n\n\tfunction clone (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, clone)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n\t\tvar o2 = {}\n\t\trefs.push(o)\n\t\trefsNew.push(o2)\n\t\tfor (var k in o) {\n\t\t\tif (Object.hasOwnProperty.call(o, k) === false) continue\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), clone))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar i = refs.indexOf(cur)\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\to2[k] = refsNew[i]\n\t\t\t\t} else {\n\t\t\t\t\to2[k] = clone(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trefs.pop()\n\t\trefsNew.pop()\n\t\treturn o2\n\t}\n\n\tfunction cloneProto (o) {\n\t\tif (typeof o !== 'object' || o === null) return o\n\t\tif (o instanceof Date) return new Date(o)\n\t\tif (Array.isArray(o)) return cloneArray(o, cloneProto)\n\t\tif (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n\t\tif (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n\t\tvar o2 = {}\n\t\trefs.push(o)\n\t\trefsNew.push(o2)\n\t\tfor (var k in o) {\n\t\t\tvar cur = o[k]\n\t\t\tif (typeof cur !== 'object' || cur === null) {\n\t\t\t\to2[k] = cur\n\t\t\t} else if (cur instanceof Date) {\n\t\t\t\to2[k] = new Date(cur)\n\t\t\t} else if (cur instanceof Map) {\n\t\t\t\to2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (cur instanceof Set) {\n\t\t\t\to2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n\t\t\t} else if (ArrayBuffer.isView(cur)) {\n\t\t\t\to2[k] = copyBuffer(cur)\n\t\t\t} else {\n\t\t\t\tvar i = refs.indexOf(cur)\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\to2[k] = refsNew[i]\n\t\t\t\t} else {\n\t\t\t\t\to2[k] = cloneProto(cur)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trefs.pop()\n\t\trefsNew.pop()\n\t\treturn o2\n\t}\n}\n\nexport default rfdc()\n","import {RefuseFiber} from \"../render.js\";\n\nexport default function isRefuseFiber(fiber: any): fiber is RefuseFiber {\n\treturn typeof fiber === 'object' && fiber !== null && 'type' in fiber && typeof fiber.type === 'function';\n}\n","// @ts-ignore\nimport htm from '../node_modules/htm/src/index.mjs'\n// @ts-ignore\nimport clone from './utils/rfdc.js'\nimport isChildfulFiber from \"./utils/isChildfulFiber.js\";\nimport isRefuseFiber from \"./utils/isRefuseFiber.js\";\nimport {Ref} from \"./hooks.js\";\nimport './getEventListeners.js'\n\n//-----------------------------------------------------------------------------\n\ninterface HtmlFiber {\n\t// Data that use to create DOM element\n\trenderType?: string\n\trenderProps: Props\n\tchild: Fiber[]\n\tref?: Ref\n\tDOMNode?: Element | DocumentFragment\n}\n\nexport interface RefuseFiber extends HtmlFiber {\n\tisProcessed: boolean // Mark fiber as processed, processed fiber will not be process (to prevent children component to be processed multiple times)\n\tisDirty: boolean // Mark fiber as dirty, dirty fiber will be re-rendered\n\t// Data using to construct fiber\n\ttype: RefuseComponent\n\tprops: Props // Didn't include key and ref\n\t// Fiber state\n\tstate: any[]\n\tstateIndex: number\n\teffects: {\n\t\tdeps: unknown[] | undefined\n\t\tcallback: () => void | (() => void)\n\t\tcleanup: void | (() => void)\n\t\trun: boolean\n\t\tisLayout: boolean\n\t}[]\n\teffectIndex: number\n\tmemos: {\n\t\tdeps: unknown[] | undefined\n\t\tfactory: () => any\n\t\tvalue: any\n\t}[]\n\tmemoIndex: number\n}\n\ninterface Props {\n\t[key: string]: any\n}\n\nexport type Fiber = RefuseFiber | HtmlFiber | string | number | false | null | undefined\n\nexport type RefuseElement = Fiber | Fiber[] | RefuseElement[]\ntype Fuse = (strings: TemplateStringsArray, ...rest: any[]) => RefuseElement\nexport type RefuseComponent<T extends Props = Props> = (props: T, ref?: Ref) => RefuseElement\n\n// Utility types\n\nexport type ComponentProps<T extends RefuseComponent> = T extends (props: infer P, ...args: any[]) => ReturnType<T> ? P : never\nexport type ComponentRef<T extends RefuseComponent> = T extends (arg0: any, ref: infer P, ...args: any[]) => ReturnType<T> ? P : never\n\n//-----------------------------------------------------------------------------\n\nlet rootElement: Element | DocumentFragment,\n\trootComponent: RefuseComponent,\n\trootFiber: RefuseFiber,\n\tcurrentFiber: RefuseFiber // for hooks to access data\nlet batchUpdate: Function[] = []\nlet unmountedFibers: RefuseFiber[] = []\nlet batchUpdateTimer: {value: number | undefined} = {value: undefined}\n\nlet consoleLog = console.log\nif (ENV !== \"development\") {\n\t// Disable log in production\n\tconsoleLog = (...args: any) => {}\n}\nconst originalConsoleLog = consoleLog\n\n//-----------------------------------------------------------------------------\n\nfunction Fragment({children}: { children: RefuseFiber['child'] }) {\n\treturn children\n}\n\nfunction createDefaultRefuseFiber(\n\ttype: RefuseFiber['type'],\n\tprops?: RefuseFiber[\"props\"],\n\tchild?: RefuseFiber['child'],\n\tref?: Ref\n): RefuseFiber {\n\treturn {\n\t\tref: ref,\n\t\ttype: type,\n\t\tprops: props ?? {},\n\t\tchild: child ?? [],\n\t\tisProcessed: false,\n\t\tisDirty: true,\n\t\tstate: [],\n\t\tstateIndex: 0,\n\t\teffects: [],\n\t\teffectIndex: 0,\n\t\tmemos: [],\n\t\tmemoIndex: 0,\n\t\trenderType: undefined,\n\t\trenderProps: {},\n\t}\n}\n\nfunction throwElementError(...args: any[]) {\n\tthrow new Error(...args)\n}\n\nfunction createElement(type: any, props: any, ...child: any[]): Fiber {\n\t// @ts-ignore\n\t// this[0] = 3 // disable cache\n\n\tconst ref = props?.ref\n\tdelete props?.ref\n\n\tif (typeof type === 'function') { // Capturing phase\n\t\treturn createDefaultRefuseFiber(type, props, child, ref)\n\t} else {\n\n\t\tif (typeof type !== 'string') {\n\t\t\tthrowElementError('Invalid element type, required string, received ' + typeof type + ' instead: ' + JSON.stringify(type) + '.')\n\t\t}\n\n\t\tif (!props) {\n\t\t\tprops = {}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols(props).length > 0) {\n\t\t\tthrowElementError('Invalid element prop name in '+type+', we don\\'t support for symbol prop name, please try another primitive.')\n\t\t}\n\n\t\tfor (const prop of Object.values(props)) {\n\t\t\tif (typeof prop !== 'string' && typeof prop !== 'number' && typeof prop !== 'function') {\n\t\t\t\tthrowElementError('Invalid element prop value in ' + type + ', we only support for string, number and function prop value.')\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tref: ref,\n\t\t\trenderType: type,\n\t\t\trenderProps: props ?? {},\n\t\t\tchild: child,\n\t\t}\n\t}\n}\n\nconst fuse: Fuse = htm.bind(createElement)\n\nfunction markAsUnmounted(fiber: Fiber | string | number) {\n\tif (typeof fiber !== 'number' && typeof fiber !== 'string' && isRefuseFiber(fiber)) {\n\t\tunmountedFibers.push(fiber)\n\t}\n}\n\nfunction* getNextRefuseFiberInChild(fiber: Fiber): Generator<[RefuseFiber['child'], number]> {\n\tif (Array.isArray(fiber)) {\n\t\tfor (const i in fiber) {\n\t\t\tif (isRefuseFiber(fiber[i])) {\n\t\t\t\tyield [fiber, i as unknown as number]\n\t\t\t} else {\n\t\t\t\tfor (let j of getNextRefuseFiberInChild(fiber[i])) {\n\t\t\t\t\tyield j\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (isChildfulFiber(fiber)) {\n\t\tfor (const i in fiber.child) {\n\t\t\tif (isRefuseFiber(fiber.child[i])) {\n\t\t\t\t// TODO: fix this cast, i don't know why typescript tell i is a string\n\t\t\t\tyield [fiber.child, i as unknown as number]\n\t\t\t} else {\n\t\t\t\tfor (let j of getNextRefuseFiberInChild(fiber.child[i])) {\n\t\t\t\t\tyield j\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction addComponentToElement(fiber: Fiber, oldFiber: Fiber, element: Element | DocumentFragment) {\n\tif (Array.isArray(fiber)) {\n\t\tfiber.forEach((c, i) => {\n\t\t\tlet oldFiberChild\n\t\t\tif (typeof oldFiber !== \"string\" && typeof oldFiber !== \"number\" && oldFiber && oldFiber.DOMNode) {\n\t\t\t\tif (Array.isArray(oldFiber)) {\n\t\t\t\t\toldFiberChild = oldFiber[i]\n\t\t\t\t} else {\n\t\t\t\t\toldFiberChild = oldFiber.child[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\taddComponentToElement(c, oldFiberChild, element)\n\t\t})\n\t} else {\n\t\tif (fiber !== false && fiber !== null && fiber !== undefined) {\n\t\t\tif (fiber && typeof fiber !== \"string\" && typeof fiber !== \"number\") {\n\t\t\t\tif (!isRefuseFiber(fiber)) { // If this is a refuse fiber, we already process it\n\t\t\t\t\tlet oldChild\n\t\t\t\t\tif (typeof oldFiber !== \"string\" && typeof oldFiber !== \"number\" && oldFiber && oldFiber.DOMNode) {\n\t\t\t\t\t\tfiber.DOMNode = oldFiber.DOMNode\n\t\t\t\t\t\toldChild = oldFiber.child\n\t\t\t\t\t}\n\t\t\t\t\ttoDOMElement(fiber, oldChild)\n\t\t\t\t}\n\t\t\t\telement.appendChild(fiber.DOMNode!)\n\t\t\t} else {\n\t\t\t\telement.appendChild(document.createTextNode(String(fiber)))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction toDOMElement(fiber: HtmlFiber | RefuseFiber, oldChild: HtmlFiber['child'] | undefined) {\n\n\tif (\"isProcessed\" in fiber && fiber.isProcessed) {\n\t\treturn\n\t} else {\n\n\t\tlet element: Element | DocumentFragment = new DocumentFragment()\n\n\t\tif (fiber.renderType !== undefined) {\n\n\t\t\tlet attributes: Record<string, any> = {},\n\t\t\t\tevents: Record<string, any> = {}\n\n\t\t\tfor (let key in fiber.renderProps) {\n\t\t\t\tif (![null, undefined, false].includes(fiber.renderProps[key])) {\n\t\t\t\t\tif (typeof fiber.renderProps[key] !== \"function\") {\n\t\t\t\t\t\tattributes[key] = fiber.renderProps[key]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevents[key.slice(2)] = fiber.renderProps[key] // remove first 2 characters of attribute name (which is \"on\") to make it a valid event name then add it to the element\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fiber?.DOMNode && fiber.DOMNode instanceof Element && fiber.DOMNode.tagName.toLowerCase() === fiber.renderType) {\n\t\t\t\t// Reuse oldFiber.DOMNode\n\t\t\t\telement = fiber.DOMNode\n\n\t\t\t\tfor (const attr of fiber.DOMNode.attributes) {\n\t\t\t\t\tif (!(attr.name in attributes)) {\n\t\t\t\t\t\telement.removeAttribute(attr.name)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst oldEvents: Record<string, any[]> = element.getEventListeners()\n\n\t\t\t\tfor (const eventName in oldEvents) {\n\t\t\t\t\toldEvents[eventName].forEach(event => {\n\t\t\t\t\t\telement.removeEventListener(eventName, event.listener)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\twhile (element.firstChild) {\n\t\t\t\t\telement.removeChild(element.firstChild);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// Init new DOMNode\n\t\t\t\telement = document.createElement(fiber.renderType)\n\t\t\t}\n\n\t\t\tfor (let key in attributes) {\n\t\t\t\telement.setAttribute(key, attributes[key])\n\t\t\t}\n\n\t\t\tfor (let key in events) {\n\t\t\t\telement.addEventListener(key, events[key])\n\t\t\t}\n\n\t\t\tif (fiber?.ref) {\n\t\t\t\tfiber.ref.current = element\n\t\t\t}\n\t\t}\n\n\t\tfiber.DOMNode = element\n\t}\n\n\tfiber.child.forEach((child, index) => {\n\t\taddComponentToElement(child, oldChild?.[index], fiber.DOMNode!)\n\t})\n}\n\n\nfunction reconcileChild(parentFiberIsDirty: boolean, oldChild: RefuseFiber['child'] | undefined, child: RefuseFiber['child'], DOMNode: Exclude<RefuseFiber['DOMNode'], undefined>) {\n\t// TODO: match key-ed child\n\tfor (const i in child) {\n\t\tif (typeof child[i] !== 'number' && typeof child[i] !== 'string') {\n\t\t\tif (\n\t\t\t\t(isRefuseFiber(child[i]) && parentFiberIsDirty) || // If there are some component passed as child to this child (only happen when parent is dirty)\n\t\t\t\tArray.isArray(child[i]) ||// If the child is an array\n\t\t\t\t!isRefuseFiber(child[i]) // If the child is html fiber, it can still contain refuse fiber deep inside it\n\t\t\t) {\n\t\t\t\tconst nextOldChild = getNextRefuseFiberInChild(oldChild?.[i])\n\t\t\t\tconst nextChild = getNextRefuseFiberInChild(child[i])\n\t\t\t\t// Iterate in indirect child\n\t\t\t\tfor (const j of nextChild) {\n\t\t\t\t\tconst oldChildNext = nextOldChild.next().value\n\t\t\t\t\tj[0][j[1]] = reconcile(parentFiberIsDirty, oldChildNext?.[0]?.[oldChildNext[1]], j[0][j[1]] as RefuseFiber) // result getNextRefuseFiberInChild will always be RefuseFiber\n\t\t\t\t}\n\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tfor (const j of nextOldChild) {\n\t\t\t\t\tmarkAsUnmounted(j[0][j[1]])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRefuseFiber(child[i])) {\n\t\t\t\t// Then we can reconcile the child itself\n\t\t\t\tchild[i] = reconcile(\n\t\t\t\t\tparentFiberIsDirty,\n\t\t\t\t\t// @ts-expect-error Somehow type-guard is not working here\n\t\t\t\t\tisRefuseFiber(oldChild?.[i]) ? oldChild[i] : undefined,\n\t\t\t\t\tchild[i]\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(child[i])) {\n\t\t\t\t\t// consoleLog('---------array of fiber', clone(child[i]), clone(oldChild?.[i]))\n\t\t\t\t} else {\n\t\t\t\t\t// consoleLog('---------html fiber', clone(child[i]), clone(oldChild?.[i]))\n\t\t\t\t}\n\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tif (isRefuseFiber(oldChild?.[i])) {\n\t\t\t\t\tmarkAsUnmounted(oldChild?.[i])\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\t// child[i] is number or string\n\n\t\t\tif (oldChild?.[i] !== child[i]) {\n\t\t\t\t// Clean old child that not match with new child if there are any\n\t\t\t\tif (isRefuseFiber(oldChild?.[i])) {\n\t\t\t\t\tmarkAsUnmounted(oldChild?.[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction reconcile(parentFiberIsDirty: boolean | undefined, oldFiber: RefuseFiber | undefined, fiber: RefuseFiber): RefuseFiber {\n\n\tif (fiber.isProcessed) return fiber\n\n\tconst oldChild = oldFiber?.child\n\n\tif (fiber.type !== Fragment) {\n\n\t\tlet isReuse = false\n\n\t\tif (oldFiber) {\n\t\t\tif (oldFiber.type === fiber.type) {\n\t\t\t\t// consoleLog('Reuse:', clone(oldFiber))\n\t\t\t\tisReuse = true\n\t\t\t\tfiber.isDirty = oldFiber.isDirty\n\t\t\t} else {\n\t\t\t\tmarkAsUnmounted(oldFiber)\n\t\t\t}\n\t\t}\n\n\t\tfiber.isDirty = parentFiberIsDirty || fiber.isDirty\n\n\t\tif (fiber.isDirty) {\n\t\t\tconsoleLog(fiber.type.name, 'is dirty')\n\n\t\t\tlet newProps = fiber.props\n\t\t\tconst newRef = fiber.ref\n\n\t\t\tif (parentFiberIsDirty) { // If parent fiber is dirty, then props probably changed\n\t\t\t\t// Save the reference to new props and children so set it later\n\t\t\t\tnewProps = {...fiber.props, children: fiber.child ?? []}\n\t\t\t}\n\n\t\t\tif (isReuse) {\n\t\t\t\tfiber = oldFiber as RefuseFiber // If isReuse then oldFiber is RefuseFiber\n\t\t\t}\n\n\t\t\t// Save props\n\t\t\tfiber.props = newProps\n\t\t\tfiber.ref = newRef\n\n\t\t\tcurrentFiber = fiber\n\t\t\tconst result = fiber.type({...fiber.props}, fiber.ref)\n\n\t\t\tif (result === undefined || result === false || result === null) {\n\t\t\t\t// Stop reconcile child if result is undefined, null, false, empty array\n\t\t\t\tfiber.child = []\n\t\t\t} else if (Array.isArray(result)) {\n\t\t\t\t// Array of text, string\n\t\t\t\tfiber.child = result as RefuseFiber['child'] // TODO: investigate how to eliminate this type cast\n\t\t\t} else if (typeof result !== 'object' || (isRefuseFiber(result) && result.type !== fiber.type)) {\n\t\t\t\tfiber.child = [result]\n\t\t\t} else {\n\t\t\t\tfiber.renderType = result.renderType\n\t\t\t\tfiber.renderProps = result.renderProps\n\t\t\t\tfiber.child = result.child\n\t\t\t}\n\t\t\tconsoleLog('Result:', fiber.type.name, clone(fiber)) // No child state\n\t\t} else {\n\t\t\tconsoleLog(fiber.type.name, 'is clean')\n\t\t\tif (isReuse) {\n\t\t\t\tfiber = oldFiber as RefuseFiber // If isReuse then oldFiber is RefuseFiber\n\t\t\t}\n\t\t}\n\t}\n\n\treconcileChild(\"isDirty\" in fiber ? fiber.isDirty : false, oldChild, fiber.child, fiber.DOMNode!)\n\tconsoleLog('DONE: ', fiber.type.name, clone(fiber))\n\ttoDOMElement(fiber, oldChild)\n\tfiber.isProcessed = true\n\n\treturn fiber\n}\n\nfunction resetFiber(fiber: Fiber | Fiber[]) {\n\tif (typeof fiber === \"object\" && fiber) {\n\t\tif (!Array.isArray(fiber)) {\n\t\t\tif (isRefuseFiber(fiber)) {\n\t\t\t\tfiber.stateIndex = 0\n\t\t\t\tfiber.effectIndex = 0\n\t\t\t\tfiber.memoIndex = 0\n\t\t\t\tfiber.isDirty = false\n\t\t\t\tfiber.isProcessed = false\n\t\t\t}\n\n\t\t\tfiber.child.forEach(f => {\n\t\t\t\tif (typeof f === \"object\") {\n\t\t\t\t\tresetFiber(f)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tfiber.forEach(f => resetFiber(f))\n\t\t}\n\t}\n}\n\nfunction runEffects(fiber: Fiber, isLayout = false) {\n\t// Called in a bottom-up fashion, run children's effects first\n\tif (typeof fiber === \"string\" || typeof fiber === \"number\" || !fiber) return\n\n\tfiber.child.forEach(child => {\n\t\tif (Array.isArray(child)) {\n\t\t\tchild.forEach(c => runEffects(c, isLayout))\n\t\t} else {\n\t\t\trunEffects(child, isLayout)\n\t\t}\n\t})\n\n\tif (isRefuseFiber(fiber)) {\n\t\tfor (let i = 0; i < fiber.effects.length; i++) {\n\t\t\tif (fiber.effects[i].run && fiber.effects[i].isLayout === isLayout) {\n\t\t\t\tfiber.effects[i].cleanup?.()\n\t\t\t\tfiber.effects[i].cleanup = fiber.effects[i].callback()\n\t\t\t\tfiber.effects[i].run = false\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction cleanUpEffects(fiber: Fiber) {\n\t// Called in a bottom-up fashion, run children's effects first\n\tif (typeof fiber === \"string\" || typeof fiber === \"number\" || !fiber) return\n\n\tfiber.child.forEach(child => {\n\t\tif (Array.isArray(child)) {\n\t\t\tchild.forEach(c => cleanUpEffects(c))\n\t\t} else {\n\t\t\tcleanUpEffects(child)\n\t\t}\n\t})\n\n\tif (isRefuseFiber(fiber)) {\n\t\tfor (let i = 0; i < fiber.effects.length; i++) {\n\t\t\tfiber.effects[i].cleanup?.()\n\t\t}\n\t}\n}\n\nfunction rerender() {\n\tconsoleLog('----------------------------------------------------------------')\n\t// Batch update state changes\n\tconsoleLog('@@@@@@@ Batch updating...')\n\tconsoleLog = (...args) => originalConsoleLog('[State change]', ...args)\n\n\twhile (batchUpdate.length) {\n\t\tbatchUpdate.pop()!()\n\t}\n\tconsoleLog = originalConsoleLog\n\n\t// Render phase, and schedule effects to run later\n\tconsoleLog('@@@@@@@ Rendering...')\n\t// consoleLog = (...args) => originalConsoleLog('[Render]', ...args)\n\tconst newRootFiber= reconcile(undefined, rootFiber, createDefaultRefuseFiber(rootComponent))\n\tresetFiber(newRootFiber) // Reset fiber to prepare for next render\n\tconsoleLog('Result:', newRootFiber)\n\t// consoleLog = originalConsoleLog\n\n\t// Reconciliation phase: tree diffing: find out what changed, what component to mount and to unmount\n\t// https://reactjs.org/docs/reconciliation.html\n\n\t// Commit phase: commit changes to real DOM\n\trootElement.textContent = ''\n\trootElement.appendChild(newRootFiber.DOMNode!)\n\trootFiber = newRootFiber\n\t// newRootFiber.DOMNode = toDOMNode(newRootFiber, rootFiber?.DOMNode)\n\t// if (newRootFiber.DOMNode !== rootFiber?.DOMNode) {\n\t// \trootElement.textContent = ''\n\t// \trootElement.appendChild(newRootFiber.DOMNode!)\n\t// \trootFiber = newRootFiber\n\t// }\n\n\t// Layout Effects goes here and block browser paint\n\t// After running all layout effects at once, if changes are made, trigger re-render again before browser paint\n\t// using requestAnimationFrame\n\tconst channel = new MessageChannel()\n\n\tfunction runEffectsFunc() {\n\t\t// Run effects and cleanup effects of unmounted components\n\t\t// 1: if changes are made in layout effects: run before browser paint\n\t\t// 2: if no changes are made in layout effects: run after browser painted to the screen\n\t\tconsoleLog('@@@@@@ Running effects...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Effect]', ...args)\n\t\trunEffects(rootFiber)\n\t\tconsoleLog = originalConsoleLog\n\n\t\t// Clean up unmounted components last\n\t\tconsoleLog('@@@@@@ Cleaning up unmounted components...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Effect cleanup]', ...args)\n\t\twhile (unmountedFibers.length) {\n\t\t\tcleanUpEffects(unmountedFibers.pop()!)\n\t\t}\n\t\tconsoleLog = originalConsoleLog\n\t}\n\n\trequestAnimationFrame(function () {\n\n\t\tconsoleLog('@@@@@@ Running layout effects before repaint...')\n\t\tconsoleLog = (...args) => originalConsoleLog('[Layout effect]', ...args)\n\t\trunEffects(rootFiber, true)\n\t\tconsoleLog = originalConsoleLog\n\n\t\tif (batchUpdate.length) {\n\t\t\trunEffectsFunc()\n\t\t\tclearTimeout(batchUpdateTimer.value)\n\t\t\trerender()\n\t\t} else {\n\t\t\tchannel.port1.onmessage = runEffectsFunc\n\t\t\tchannel.port2.postMessage(undefined) // Guarantee to postMessage after paint\n\t\t\tconsoleLog('@@@@@@ Browser painted to the screen')\n\t\t}\n\t})\n}\n\nfunction render(component: RefuseComponent, element: Element | null) {\n\tif (element) {\n\t\trootElement = element\n\t} else {\n\t\trootElement = document.createDocumentFragment()\n\t\tdocument.body.prepend(rootElement)\n\t}\n\n\trootComponent = component\n\n\trerender()\n}\n\nexport {\n\trender,\n\tfuse,\n\tFragment,\n\tcurrentFiber,\n\tbatchUpdate,\n\tbatchUpdateTimer,\n\trerender\n}\n","// save the original methods before overwriting them\nElement.prototype._addEventListener = Element.prototype.addEventListener;\nElement.prototype._removeEventListener = Element.prototype.removeEventListener;\n\n/**\n * [addEventListener description]\n * @param {[type]}  type       [description]\n * @param {[type]}  listener   [description]\n * @param {Boolean} useCapture [description]\n */\nElement.prototype.addEventListener = function(type,listener,useCapture=false) {\n\t// declare listener\n\tthis._addEventListener(type,listener,useCapture);\n\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\tif(!this.eventListenerList[type]) this.eventListenerList[type] = [];\n\n\t// add listener to  event tracking list\n\tthis.eventListenerList[type].push( {type, listener, useCapture} );\n};\n\n/**\n * [removeEventListener description]\n * @param  {[type]}  type       [description]\n * @param  {[type]}  listener   [description]\n * @param  {Boolean} useCapture [description]\n * @return {[type]}             [description]\n */\nElement.prototype.removeEventListener = function(type,listener,useCapture=false) {\n\t// remove listener\n\tthis._removeEventListener(type,listener,useCapture);\n\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\tif(!this.eventListenerList[type]) this.eventListenerList[type] = [];\n\n\t// Find the event in the list, If a listener is registered twice, one\n\t// with capture and one without, remove each one separately. Removal of\n\t// a capturing listener does not affect a non-capturing version of the\n\t// same listener, and vice versa.\n\tfor(let i=0; i<this.eventListenerList[type].length; i++){\n\t\tif( this.eventListenerList[type][i].listener===listener && this.eventListenerList[type][i].useCapture===useCapture){\n\t\t\tthis.eventListenerList[type].splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// if no more events of the removed event type are left,remove the group\n\tif(this.eventListenerList[type].length==0) delete this.eventListenerList[type];\n};\n\n\n/**\n * [getEventListeners description]\n * @param  {[type]} type [description]\n * @return {[type]}      [description]\n */\nElement.prototype.getEventListeners = function(type){\n\tif(!this.eventListenerList) this.eventListenerList = {};\n\n\t// return requested listeners type or all them\n\tif(type===undefined)  return this.eventListenerList;\n\treturn this.eventListenerList[type];\n};\n","import {RefuseFiber} from \"../render.js\";\n\nexport default function isChildfulFiber(fiber: any): fiber is RefuseFiber | HTMLElement {\n\treturn typeof fiber === 'object' && fiber !== null && 'child' in fiber;\n}\n","import type {ComponentProps, ComponentRef, RefuseComponent, RefuseFiber} from \"./render.js\";\nimport {batchUpdate, batchUpdateTimer, currentFiber, rerender} from \"./render.js\";\n\nexport function useState<T = Exclude<unknown, Function>>(initialValue: T): [T, (newValue: T | ((prevState: T) => T)) => void] {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.stateIndex++ // this change overtime too\n\n\tthisFiber.state[thisIndex] ??= initialValue\n\n\tfunction setState(newState:  T | ((prevState: T) => T)) {\n\t\tif (!batchUpdate.length) batchUpdateTimer.value = setTimeout(rerender, 0)\n\n\t\tbatchUpdate.push(function() {\n\n\t\t\tif (typeof newState === 'function') {\n\t\t\t\tnewState = (newState as (newValue: T) => T)(thisFiber.state[thisIndex])\n\t\t\t}\n\n\t\t\tif (thisFiber.state[thisIndex] !== newState) {\n\t\t\t\tconsole.log('Update from', thisFiber.state[thisIndex], 'to', newState, 'in', thisFiber.type.name)\n\t\t\t\tthisFiber.state[thisIndex] = newState\n\t\t\t\tthisFiber.isDirty = true\n\t\t\t}\n\t\t})\n\t}\n\n\treturn [thisFiber.state[thisIndex], setState]\n}\n\ntype effectCallback = () => (() => void) | void\n\nexport function useEffect(callback: effectCallback, deps: RefuseFiber['effects'][number]['deps'], isLayout = false) {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.effectIndex++ // this change overtime too\n\n\tlet run = false\n\n\t// No dependency, run every rerender\n\tif (!deps) {\n\t\trun = true\n\t}\n\t// Has dependency, run if dependency changed\n\telse if (!thisFiber.effects[thisIndex] || deps.length !== thisFiber.effects[thisIndex].deps?.length\n\t\t|| deps.some((dep, i) => dep !== thisFiber.effects[thisIndex].deps?.[i])) {\n\t\trun = true\n\t}\n\n\tif (run) {\n\t\tthisFiber.effects[thisIndex] = {\n\t\t\t...thisFiber.effects[thisIndex],\n\t\t\tdeps,\n\t\t\tcallback,\n\t\t\trun,\n\t\t\tisLayout,\n\t\t}\n\t}\n}\n\nexport const useLayoutEffect = (callback: effectCallback, deps: RefuseFiber['effects'][number]['deps']) => useEffect(callback, deps, true)\n\nexport function useMemo<T>(factory: () => T, deps: RefuseFiber['memos'][number]['deps']): T {\n\tconst thisFiber = currentFiber // because currentFiber change overtime, we must preserve it inside useState\n\tconst thisIndex = thisFiber.memoIndex++ // this change overtime too\n\n\tlet update = false\n\n\t// No dependency, run every rerender\n\tif (!deps) {\n\t\tupdate = true\n\t}\n\t// Has dependency, run if dependency changed\n\telse if (!thisFiber.memos[thisIndex] || deps.length !== thisFiber.memos[thisIndex].deps?.length\n\t\t|| deps.some((dep, i) => dep !== thisFiber.memos[thisIndex].deps?.[i])) {\n\t\tupdate = true\n\t}\n\n\tif (update) {\n\t\tthisFiber.memos[thisIndex] = {\n\t\t\t...thisFiber.memos[thisIndex],\n\t\t\tdeps,\n\t\t\tfactory,\n\t\t\tvalue: factory(),\n\t\t}\n\t}\n\n\treturn thisFiber.memos[thisIndex].value\n}\n\nexport function useCallback<T = any>(callback: T, deps: any[]): T {\n\treturn useMemo(() => callback, deps)\n}\n\nexport type Ref<T = any> = {\n\tcurrent: T | null\n}\n\nexport function useRef<T = any>(initialValue: T): Ref<T> {\n\treturn useMemo(() => ({ current: initialValue }), [])\n}\n\nfunction shallowEqual<T extends Record<string, any>>(prevProps: T | null, nextProps: T): boolean {\n\tif (prevProps === null) return false\n\n\tconst prevKeys = Object.keys(prevProps)\n\tconst nextKeys = Object.keys(nextProps)\n\n\tif (prevKeys.length !== nextKeys.length) return false\n\tif (prevKeys.length === 0) return true\n\n\tfor (let i = 0; i < prevKeys.length; i++) {\n\t\tif (prevKeys[i] !== 'children' && prevProps[prevKeys[i]] !== nextProps[prevKeys[i]]) return false\n\t}\n\n\treturn shallowEqual(prevProps.children, nextProps.children)\n}\n\nexport function memo<T extends RefuseComponent = RefuseComponent>(component: T, areEqual: ((prevProps: ComponentProps<T> | null, nextProps: ComponentProps<T>) => boolean) = shallowEqual<ComponentProps<T>>) {\n\tconst memoComponent = function(props: ComponentProps<T>, ref: ComponentRef<T>) {\n\t\tconst prevProps = useRef<ComponentProps<T> | null>(null)\n\t\tuseEffect(() => {\n\t\t\tprevProps.current = props\n\t\t}, [props])\n\t\tconsole.log('[Memo check]', areEqual(prevProps.current, props), prevProps.current, props)\n\n\t\treturn areEqual(prevProps.current, props) ? currentFiber : component(props, ref)\n\t}\n\n\t// Name the memo component for debugging purpose\n\tObject.defineProperty(memoComponent, 'name', {value: component.name, writable: false});\n\treturn memoComponent\n}\n"],"names":["evaluate","h","built","fields","args","tmp","i","length","type","value","Object","assign","apply","push","build","statics","char","propName","mode","buffer","quote","current","commit","field","replace","j","CACHES","Map","cur","Buffer","from","constructor","slice","byteOffset","clone","opts","circles","refs","proto","cloneProto","o","Date","Array","isArray","cloneArray","Set","o2","refsNew","k","ArrayBuffer","isView","copyBuffer","indexOf","pop","hasOwnProperty","call","a","fn","keys","a2","index","rfdcCircles","isRefuseFiber","fiber","rootElement","rootComponent","rootFiber","currentFiber","Element","prototype","_addEventListener","addEventListener","_removeEventListener","removeEventListener","listener","useCapture","this","eventListenerList","splice","getEventListeners","undefined","unmountedFibers","batchUpdateTimer","consoleLog","console","log","originalConsoleLog","children","createDefaultRefuseFiber","props","child","ref","isProcessed","isDirty","state","stateIndex","effects","effectIndex","memos","memoIndex","renderType","renderProps","throwElementError","Error","fuse","get","set","arguments","bind","_props","_props2","_props3","JSON","stringify","getOwnPropertySymbols","prop","values","getNextRefuseFiberInChild","isChildfulFiber","addComponentToElement","oldFiber","element","forEach","c","oldFiberChild","DOMNode","oldChild","toDOMElement","appendChild","document","createTextNode","String","DocumentFragment","events","key","includes","attributes","tagName","toLowerCase","attr","name","removeAttribute","oldEvents","eventName","event","firstChild","removeChild","createElement","setAttribute","reconcile","parentFiberIsDirty","Fragment","isReuse","markAsUnmounted","newProps","newRef","result","_extends","nextOldChild","nextChild","_oldChildNext$","oldChildNext","next","reconcileChild","resetFiber","f","runEffects","isLayout","_fiber$effects$i$clea","_fiber$effects$i","run","cleanup","callback","cleanUpEffects","_fiber$effects$i$clea2","_fiber$effects$i2","rerender","batchUpdate","newRootFiber","textContent","MessageChannel","runEffectsFunc","requestAnimationFrame","clearTimeout","channel","port1","onmessage","port2","postMessage","render","component","createDocumentFragment","body","prepend","useState","initialValue","thisFiber","thisIndex","_thisFiber$state","newState","setTimeout","useEffect","deps","_thisFiber$effects$th","some","dep","_thisFiber$effects$th2","useLayoutEffect","useMemo","factory","_thisFiber$memos$this","update","_thisFiber$memos$this2","useCallback","shallowEqual","prevProps","nextProps","prevKeys","nextKeys","memo","areEqual","memoComponent","useRef","defineProperty","writable"],"mappings":"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"}